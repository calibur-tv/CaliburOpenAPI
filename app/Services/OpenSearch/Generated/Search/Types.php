<?php

namespace App\Services\OpenSearch\Generated\Search;

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use App\Services\OpenSearch\Thrift\Base\TBase;
use App\Services\OpenSearch\Thrift\Type\TType;
use App\Services\OpenSearch\Thrift\Type\TMessageType;
use App\Services\OpenSearch\Thrift\Exception\TException;
use App\Services\OpenSearch\Thrift\Exception\TProtocolException;
use App\Services\OpenSearch\Thrift\Protocol\TProtocol;
use App\Services\OpenSearch\Thrift\Protocol\TBinaryProtocolAccelerated;
use App\Services\OpenSearch\Thrift\Exception\TApplicationException;


final class SearchType {
  const SEARCH = 0;
  const SCROLL = 1;
  static public $__names = array(
    0 => 'SEARCH',
    1 => 'SCROLL',
  );
}

final class Order {
  const DECREASE = 0;
  const INCREASE = 1;
  static public $__names = array(
    0 => 'DECREASE',
    1 => 'INCREASE',
  );
}

/**
 *
 * 传统搜索场景的主要目的是为了尽量短的时间内召回最符合的结果，所以对搜索结果进行了限制。在某些场景下需要提供更多的结果来进行分析工作，
 * 可以使用scroll接口来获取更多的结果，目前scorll只支持query与filter子句，sort子句无法支持。
 *
 * 注意事项
 * <pre>
 *  1, start值无效，通过hit值设置每次返回的结果数，即后续查询都以第一次查询指定的hit值为准；
 *  2, aggregate、sort、distinct、排序表达式无效，如果传入，查询会报错且无结果；
 *  3, 第一次查询需要完整的query、index_name、AccessKeyId等参数，后面的查询不需要传这些参数（即使传入，也会被忽略），只需要传入上一次返回的scroll_id即可；
 *  4, 不支持多应用scroll查询；
 *  5, 每次查询都必须传scroll参数，如果不传，对于第一次查询，就按正常的查询；对于后续的查询，按scroll处理，但结果中无scroll_id返回。
 *  6, 返回结果均有第一次查询中的format决定，后续传scroll_id的响应格式均同第一次；
 *  7, 如果用户传入的scroll_id是非法的，那么查询会报错，返回结果格式为json。
 *  8, 第一次查询将不返回实际文档数据，只返回scroll_id，需要再次访问才能拿到搜索结果。
 *  </pre>
 */
class DeepPaging {
  static $_TSPEC;

  /**
   * 设置scroll请求的有效期
   *
   * @param expire 指定的scroll请求有效期 默认 1m 表示一分钟，支持的时间单位包括：w=Week, d=Day, h=Hour, m=minute, s=second
   *
   * @var string
   */
  public $scrollExpire = "1m";
  /**
   * @var string
   */
  public $scrollId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'scrollExpire',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'scrollId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['scrollExpire'])) {
        $this->scrollExpire = $vals['scrollExpire'];
      }
      if (isset($vals['scrollId'])) {
        $this->scrollId = $vals['scrollId'];
      }
    }
  }

  public function getName() {
    return 'DeepPaging';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->scrollExpire);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->scrollId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeepPaging');
    if ($this->scrollExpire !== null) {
      $xfer += $output->writeFieldBegin('scrollExpire', TType::STRING, 1);
      $xfer += $output->writeString($this->scrollExpire);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->scrollId !== null) {
      $xfer += $output->writeFieldBegin('scrollId', TType::STRING, 3);
      $xfer += $output->writeString($this->scrollId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SortField {
  static $_TSPEC;

  /**
   * 排序方式字段名.
   *
   *
   * @var string
   */
  public $field = null;
  /**
   * 排序方式，有升序“INCREASE”和降序“DECREASE”两种方式。默认值为“DECREASE”
   *
   *
   * @var int
   */
  public $order =   0;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'field',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'order',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['field'])) {
        $this->field = $vals['field'];
      }
      if (isset($vals['order'])) {
        $this->order = $vals['order'];
      }
    }
  }

  public function getName() {
    return 'SortField';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->field);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->order);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SortField');
    if ($this->field !== null) {
      $xfer += $output->writeFieldBegin('field', TType::STRING, 1);
      $xfer += $output->writeString($this->field);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->order !== null) {
      $xfer += $output->writeFieldBegin('order', TType::I32, 3);
      $xfer += $output->writeI32($this->order);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * 排序字段及方式
 *
 */
class Sort {
  static $_TSPEC;

  /**
   * @var \App\Services\OpenSearch\Generated\Search\SortField[]
   */
  public $sortFields = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sortFields',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\OpenSearch\Generated\Search\SortField',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sortFields'])) {
        $this->sortFields = $vals['sortFields'];
      }
    }
  }

  public function getName() {
    return 'Sort';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->sortFields = array();
            $_size21 = 0;
            $_etype24 = 0;
            $xfer += $input->readListBegin($_etype24, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $elem26 = null;
              $elem26 = new \App\Services\OpenSearch\Generated\Search\SortField();
              $xfer += $elem26->read($input);
              $this->sortFields []= $elem26;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Sort');
    if ($this->sortFields !== null) {
      if (!is_array($this->sortFields)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sortFields', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->sortFields));
        {
          foreach ($this->sortFields as $iter27)
          {
            $xfer += $iter27->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * 增加了此内容后，fieldName字段可能会被截断、飘红等。
 *
 */
class Summary {
  static $_TSPEC;

  /**
   * 指定的生效的字段。此字段必需为可分词的text类型的字段。
   *
   *
   * @var string
   */
  public $summary_field = null;
  /**
   * 指定结果集返回的词字段的字节长度，一个汉字为2个字节。
   *
   *
   * @var string
   */
  public $summary_len = null;
  /**
   * 指定用什么符号来标注未展示完的数据，例如“...”。
   *
   *
   * @var string
   */
  public $summary_ellipsis = "...";
  /**
   * 指定query命中几段summary内容。
   *
   *
   * @var string
   */
  public $summary_snippet = null;
  /**
   * 指定命中的query的标红标签，可以为em等。
   *
   *
   * @var string
   */
  public $summary_element = null;
  /**
   * 指定标签前缀。
   *
   *
   * @var string
   */
  public $summary_element_prefix = null;
  /**
   * 指定标签后缀。
   *
   *
   * @var string
   */
  public $summary_element_postfix = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'summary_field',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'summary_len',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'summary_ellipsis',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'summary_snippet',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'summary_element',
          'type' => TType::STRING,
          ),
        11 => array(
          'var' => 'summary_element_prefix',
          'type' => TType::STRING,
          ),
        13 => array(
          'var' => 'summary_element_postfix',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['summary_field'])) {
        $this->summary_field = $vals['summary_field'];
      }
      if (isset($vals['summary_len'])) {
        $this->summary_len = $vals['summary_len'];
      }
      if (isset($vals['summary_ellipsis'])) {
        $this->summary_ellipsis = $vals['summary_ellipsis'];
      }
      if (isset($vals['summary_snippet'])) {
        $this->summary_snippet = $vals['summary_snippet'];
      }
      if (isset($vals['summary_element'])) {
        $this->summary_element = $vals['summary_element'];
      }
      if (isset($vals['summary_element_prefix'])) {
        $this->summary_element_prefix = $vals['summary_element_prefix'];
      }
      if (isset($vals['summary_element_postfix'])) {
        $this->summary_element_postfix = $vals['summary_element_postfix'];
      }
    }
  }

  public function getName() {
    return 'Summary';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->summary_field);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->summary_len);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->summary_ellipsis);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->summary_snippet);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->summary_element);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->summary_element_prefix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->summary_element_postfix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Summary');
    if ($this->summary_field !== null) {
      $xfer += $output->writeFieldBegin('summary_field', TType::STRING, 1);
      $xfer += $output->writeString($this->summary_field);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->summary_len !== null) {
      $xfer += $output->writeFieldBegin('summary_len', TType::STRING, 3);
      $xfer += $output->writeString($this->summary_len);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->summary_ellipsis !== null) {
      $xfer += $output->writeFieldBegin('summary_ellipsis', TType::STRING, 5);
      $xfer += $output->writeString($this->summary_ellipsis);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->summary_snippet !== null) {
      $xfer += $output->writeFieldBegin('summary_snippet', TType::STRING, 7);
      $xfer += $output->writeString($this->summary_snippet);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->summary_element !== null) {
      $xfer += $output->writeFieldBegin('summary_element', TType::STRING, 9);
      $xfer += $output->writeString($this->summary_element);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->summary_element_prefix !== null) {
      $xfer += $output->writeFieldBegin('summary_element_prefix', TType::STRING, 11);
      $xfer += $output->writeString($this->summary_element_prefix);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->summary_element_postfix !== null) {
      $xfer += $output->writeFieldBegin('summary_element_postfix', TType::STRING, 13);
      $xfer += $output->writeString($this->summary_element_postfix);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * 添加统计信息(aggregate)
 *
 * 一个关键词通常能命中数以万计的文档，用户不太可能浏览所有文档来获取信息。而用户感兴趣的
 * 可 能是一些统计类的信息，比如，查询“手机”这个关键词，想知道每个卖家所有商品中的最高价格。
 * 则可以按照卖家的user_id分组，统计每个小组中最大的price值，例如：
 * groupKey:user_id,aggFun:max(price)
 *
 * 相关wiki，请查询：
 * @link http://docs.aliyun.com/?spm=5176.2020520121.103.8.VQIcGd&tag=tun#/pub/opensearch/api-reference/query-clause&aggregate-clause
 *
 */
class Aggregate {
  static $_TSPEC;

  /**
   * 指定需要统计的字段名称。
   *
   *
   * @var string
   */
  public $groupKey = null;
  /**
   * 指定统计的方法。当前支持：count、max、min、sum等。
   *
   *
   * @var string
   */
  public $aggFun = null;
  /**
   * 指定统计范围。
   *
   *
   * @var string
   */
  public $range = null;
  /**
   * 最大组个数。
   *
   *
   * @var string
   */
  public $maxGroup = null;
  /**
   * 指定过滤某些统计。
   *
   *
   * @var string
   */
  public $aggFilter = null;
  /**
   * 指定抽样的阈值。
   *
   *
   * @var string
   */
  public $aggSamplerThresHold = null;
  /**
   * 指定抽样的步长。
   *
   *
   * @var string
   */
  public $aggSamplerStep = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'groupKey',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'aggFun',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'range',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'maxGroup',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'aggFilter',
          'type' => TType::STRING,
          ),
        11 => array(
          'var' => 'aggSamplerThresHold',
          'type' => TType::STRING,
          ),
        13 => array(
          'var' => 'aggSamplerStep',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['groupKey'])) {
        $this->groupKey = $vals['groupKey'];
      }
      if (isset($vals['aggFun'])) {
        $this->aggFun = $vals['aggFun'];
      }
      if (isset($vals['range'])) {
        $this->range = $vals['range'];
      }
      if (isset($vals['maxGroup'])) {
        $this->maxGroup = $vals['maxGroup'];
      }
      if (isset($vals['aggFilter'])) {
        $this->aggFilter = $vals['aggFilter'];
      }
      if (isset($vals['aggSamplerThresHold'])) {
        $this->aggSamplerThresHold = $vals['aggSamplerThresHold'];
      }
      if (isset($vals['aggSamplerStep'])) {
        $this->aggSamplerStep = $vals['aggSamplerStep'];
      }
    }
  }

  public function getName() {
    return 'Aggregate';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->groupKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->aggFun);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->range);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->maxGroup);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->aggFilter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->aggSamplerThresHold);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->aggSamplerStep);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Aggregate');
    if ($this->groupKey !== null) {
      $xfer += $output->writeFieldBegin('groupKey', TType::STRING, 1);
      $xfer += $output->writeString($this->groupKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->aggFun !== null) {
      $xfer += $output->writeFieldBegin('aggFun', TType::STRING, 3);
      $xfer += $output->writeString($this->aggFun);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->range !== null) {
      $xfer += $output->writeFieldBegin('range', TType::STRING, 5);
      $xfer += $output->writeString($this->range);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxGroup !== null) {
      $xfer += $output->writeFieldBegin('maxGroup', TType::STRING, 7);
      $xfer += $output->writeString($this->maxGroup);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->aggFilter !== null) {
      $xfer += $output->writeFieldBegin('aggFilter', TType::STRING, 9);
      $xfer += $output->writeString($this->aggFilter);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->aggSamplerThresHold !== null) {
      $xfer += $output->writeFieldBegin('aggSamplerThresHold', TType::STRING, 11);
      $xfer += $output->writeString($this->aggSamplerThresHold);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->aggSamplerStep !== null) {
      $xfer += $output->writeFieldBegin('aggSamplerStep', TType::STRING, 13);
      $xfer += $output->writeString($this->aggSamplerStep);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * 聚合打散条件(distinct)
 *
 * 例如：检索关键词“手机”共获得10个结果，分别为：doc1，doc2，doc3，doc4，doc5，doc6，
 * doc7，doc8，doc9，doc10。其中前三个属于用户A，doc4-doc6属于用户B，剩余四个属于
 * 用户C。如果前端每页仅展示5个商品，则用户C将没有展示的机会。但是如果按照user_id进行抽
 * 取，每轮抽取1个，抽取2次，并保留抽取剩余的结果，则可以获得以下文档排列顺序：doc1、
 * doc4、doc7、doc2、doc5、doc8、doc3、doc6、doc9、doc10。可以看出，通过distinct
 * 排序，各个用户的 商品都得到了展示机会，结果排序更趋于合理。
 */
class Distinct {
  static $_TSPEC;

  /**
   * 为用户用于做distinct抽取的字段，该字段要求为可过滤字段。
   *
   *
   * @var string
   */
  public $key = null;
  /**
   * 为一次抽取的document数量，默认值为1。
   *
   *
   * @var int
   */
  public $distCount = 1;
  /**
   * 为抽取的次数，默认值为1。
   *
   *
   * @var int
   */
  public $distTimes = 1;
  /**
   * 为是否保留抽取之后剩余的结果，true为保留，false则丢弃，丢弃时totalHits的个数会减去被distinct而丢弃的个数，但这个结果不一定准确，默认为true。
   *
   *
   * @var bool
   */
  public $reserved = true;
  /**
   * 为过滤条件，被过滤的doc不参与distinct，只在后面的 排序中，这些被过滤的doc将和被distinct出来的第一组doc一起参与排序。默认是全部参与distinct。
   *
   *
   * @var string
   */
  public $distFilter = null;
  /**
   * 当reserved为false时，设置update_total_hit为true，则最终total_hit会减去被distinct丢弃的的数目（不一定准确），为false则不减； 默认为false。
   *
   *
   * @var bool
   */
  public $updateTotalHit = false;
  /**
   * 指定档位划分阈值。
   *
   *
   * @var string
   */
  public $grade = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'key',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'distCount',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'distTimes',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'reserved',
          'type' => TType::BOOL,
          ),
        9 => array(
          'var' => 'distFilter',
          'type' => TType::STRING,
          ),
        11 => array(
          'var' => 'updateTotalHit',
          'type' => TType::BOOL,
          ),
        13 => array(
          'var' => 'grade',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['key'])) {
        $this->key = $vals['key'];
      }
      if (isset($vals['distCount'])) {
        $this->distCount = $vals['distCount'];
      }
      if (isset($vals['distTimes'])) {
        $this->distTimes = $vals['distTimes'];
      }
      if (isset($vals['reserved'])) {
        $this->reserved = $vals['reserved'];
      }
      if (isset($vals['distFilter'])) {
        $this->distFilter = $vals['distFilter'];
      }
      if (isset($vals['updateTotalHit'])) {
        $this->updateTotalHit = $vals['updateTotalHit'];
      }
      if (isset($vals['grade'])) {
        $this->grade = $vals['grade'];
      }
    }
  }

  public function getName() {
    return 'Distinct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->key);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->distCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->distTimes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->reserved);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->distFilter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->updateTotalHit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->grade);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Distinct');
    if ($this->key !== null) {
      $xfer += $output->writeFieldBegin('key', TType::STRING, 1);
      $xfer += $output->writeString($this->key);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->distCount !== null) {
      $xfer += $output->writeFieldBegin('distCount', TType::I32, 3);
      $xfer += $output->writeI32($this->distCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->distTimes !== null) {
      $xfer += $output->writeFieldBegin('distTimes', TType::I32, 5);
      $xfer += $output->writeI32($this->distTimes);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reserved !== null) {
      $xfer += $output->writeFieldBegin('reserved', TType::BOOL, 7);
      $xfer += $output->writeBool($this->reserved);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->distFilter !== null) {
      $xfer += $output->writeFieldBegin('distFilter', TType::STRING, 9);
      $xfer += $output->writeString($this->distFilter);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->updateTotalHit !== null) {
      $xfer += $output->writeFieldBegin('updateTotalHit', TType::BOOL, 11);
      $xfer += $output->writeBool($this->updateTotalHit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->grade !== null) {
      $xfer += $output->writeFieldBegin('grade', TType::STRING, 13);
      $xfer += $output->writeString($this->grade);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Suggest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $suggestName = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'suggestName',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['suggestName'])) {
        $this->suggestName = $vals['suggestName'];
      }
    }
  }

  public function getName() {
    return 'Suggest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->suggestName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Suggest');
    if ($this->suggestName !== null) {
      $xfer += $output->writeFieldBegin('suggestName', TType::STRING, 1);
      $xfer += $output->writeString($this->suggestName);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Abtest {
  static $_TSPEC;

  /**
   * 场景标签。用户在控制台上配置哪些场景需要做实验，查询中只有指定了对应场景名的query才会进行实验。
   *
   * @var string
   */
  public $sceneTag = null;
  /**
   * 流量分配标识。对该值进行hash，将用户查询分配到不同的实验中，该值通常可设置为最终用户的id。
   *
   * @var string
   */
  public $flowDivider = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'sceneTag',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'flowDivider',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['sceneTag'])) {
        $this->sceneTag = $vals['sceneTag'];
      }
      if (isset($vals['flowDivider'])) {
        $this->flowDivider = $vals['flowDivider'];
      }
    }
  }

  public function getName() {
    return 'Abtest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sceneTag);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->flowDivider);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Abtest');
    if ($this->sceneTag !== null) {
      $xfer += $output->writeFieldBegin('sceneTag', TType::STRING, 1);
      $xfer += $output->writeString($this->sceneTag);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->flowDivider !== null) {
      $xfer += $output->writeFieldBegin('flowDivider', TType::STRING, 2);
      $xfer += $output->writeString($this->flowDivider);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}
